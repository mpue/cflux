// Mock axios BEFORE any imports
jest.mock('axios', () => {
  const mockGet = jest.fn();
  const mockPost = jest.fn();
  const mockPut = jest.fn();
  const mockDelete = jest.fn();
  
  (global as any).mockGet = mockGet;
  (global as any).mockPost = mockPost;
  (global as any).mockPut = mockPut;
  (global as any).mockDelete = mockDelete;
  
  return {
    __esModule: true,
    default: {
      create: jest.fn(() => ({
        get: mockGet,
        post: mockPost,
        put: mockPut,
        delete: mockDelete,
        interceptors: {
          request: {
            use: jest.fn((successFn) => {
              // Immediately invoke the interceptor function
              if (successFn) {
                successFn({ headers: {}, baseURL: '', url: '' });
              }
              return 0; // Return interceptor ID
            }),
          },
        },
      })),
    },
  };
});

import { deviceService, Device, DeviceAssignment } from '../device.service';
import axios from 'axios';

// Get mocks from global
const mockGet = (global as any).mockGet;
const mockPost = (global as any).mockPost;
const mockPut = (global as any).mockPut;
const mockDelete = (global as any).mockDelete;

// Mock localStorage
const localStorageMock = (() => {
  let store: Record<string, string> = {};

  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => {
      store[key] = value.toString();
    },
    removeItem: (key: string) => {
      delete store[key];
    },
    clear: () => {
      store = {};
    },
  };
})();

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock,
});

describe('Device Service - Complete CRUD Tests', () => {
  const mockToken = 'test-token-123';

  beforeEach(() => {
    jest.clearAllMocks();
    localStorageMock.clear();
    localStorageMock.setItem('token', mockToken);
    
    // Reset all mock implementations
    mockGet.mockReset();
    mockPost.mockReset();
    mockPut.mockReset();
    mockDelete.mockReset();
  });

  afterEach(() => {
    localStorageMock.clear();
  });

  // ============================================
  // CREATE Tests
  // ============================================
  describe('CREATE - createDevice', () => {
    it('should create device with all fields', async () => {
      const newDeviceData: Partial<Device> = {
        name: 'MacBook Pro 16"',
        serialNumber: 'C02ABC123DEF',
        manufacturer: 'Apple',
        model: 'MacBook Pro 16-inch 2023',
        category: 'Laptop',
        purchaseDate: '2023-05-15',
        warrantyUntil: '2026-05-15',
        notes: 'High-performance laptop for development',
        isActive: true,
      };

      const mockCreatedDevice: Device = {
        id: 'device-123',
        name: 'MacBook Pro 16"',
        serialNumber: 'C02ABC123DEF',
        manufacturer: 'Apple',
        model: 'MacBook Pro 16-inch 2023',
        category: 'Laptop',
        purchaseDate: '2023-05-15',
        warrantyUntil: '2026-05-15',
        notes: 'High-performance laptop for development',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockCreatedDevice });

      const result = await deviceService.createDevice(newDeviceData);

      expect(mockPost).toHaveBeenCalledWith('/devices', newDeviceData);
      expect(result).toEqual(mockCreatedDevice);
      expect(result.id).toBe('device-123');
      expect(result.serialNumber).toBe('C02ABC123DEF');
    });

    it('should create device with minimal required fields', async () => {
      const minimalData: Partial<Device> = {
        name: 'Generic Laptop',
      };

      const mockDevice: Device = {
        id: 'device-456',
        name: 'Generic Laptop',
        isActive: true,
        createdAt: '2026-01-01T10:30:00Z',
        updatedAt: '2026-01-01T10:30:00Z',
      };

      mockPost.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(minimalData);

      expect(result.name).toBe('Generic Laptop');
      expect(result.isActive).toBe(true);
    });

    it('should create inactive device', async () => {
      const inactiveDevice: Partial<Device> = {
        name: 'Old ThinkPad',
        serialNumber: 'PF123ABC',
        manufacturer: 'Lenovo',
        isActive: false,
      };

      const mockDevice: Device = {
        id: 'device-789',
        name: 'Old ThinkPad',
        serialNumber: 'PF123ABC',
        manufacturer: 'Lenovo',
        isActive: false,
        createdAt: '2026-01-01T11:00:00Z',
        updatedAt: '2026-01-01T11:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(inactiveDevice);

      expect(result.isActive).toBe(false);
      expect(result.name).toBe('Old ThinkPad');
    });

    it('should create device with warranty information', async () => {
      const deviceWithWarranty: Partial<Device> = {
        name: 'Dell XPS 15',
        serialNumber: 'DXPS123456',
        manufacturer: 'Dell',
        purchaseDate: '2025-01-15',
        warrantyUntil: '2028-01-15',
      };

      const mockDevice: Device = {
        id: 'device-warranty',
        ...deviceWithWarranty as Device,
        isActive: true,
        createdAt: '2026-01-01T11:30:00Z',
        updatedAt: '2026-01-01T11:30:00Z',
      };

      mockPost.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(deviceWithWarranty);

      expect(result.purchaseDate).toBe('2025-01-15');
      expect(result.warrantyUntil).toBe('2028-01-15');
    });

    it('should handle creation error', async () => {
      const deviceData: Partial<Device> = {
        name: 'Test Device',
        serialNumber: 'DUPLICATE123',
      };

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        json: async () => ({ error: 'Serial number already exists' }),
      });

      await expect(deviceService.createDevice(deviceData))
        .rejects.toThrow('Serial number already exists');
    });

    it('should create device with category', async () => {
      const categories = ['Laptop', 'Desktop', 'Monitor', 'Smartphone', 'Tablet', 'Printer'];

      for (const category of categories) {
        const deviceData: Partial<Device> = {
          name: `Test ${category}`,
          category: category,
        };

        const mockDevice: Device = {
          id: `device-${category}`,
          name: `Test ${category}`,
          category: category,
          isActive: true,
          createdAt: '2026-01-01T12:00:00Z',
          updatedAt: '2026-01-01T12:00:00Z',
        };

        mockPost.mockResolvedValue({ data: mockDevice });

        const result = await deviceService.createDevice(deviceData);
        expect(result.category).toBe(category);
      }
    });
  });

  // ============================================
  // READ Tests
  // ============================================
  describe('READ - getAllDevices', () => {
    it('should get all devices', async () => {
      const mockDevices: Device[] = [
        {
          id: 'device-1',
          name: 'MacBook Pro',
          manufacturer: 'Apple',
          isActive: true,
          createdAt: '2026-01-01T10:00:00Z',
          updatedAt: '2026-01-01T10:00:00Z',
        },
        {
          id: 'device-2',
          name: 'ThinkPad X1',
          manufacturer: 'Lenovo',
          isActive: true,
          createdAt: '2026-01-01T10:30:00Z',
          updatedAt: '2026-01-01T10:30:00Z',
        },
        {
          id: 'device-3',
          name: 'Dell Monitor',
          manufacturer: 'Dell',
          isActive: false,
          createdAt: '2026-01-01T11:00:00Z',
          updatedAt: '2026-01-01T11:00:00Z',
        },
      ];

      mockPost.mockResolvedValue({ data: mockDevices });

      const result = await deviceService.getAllDevices();

      // Axios mock call verification
      expect(result).toEqual(mockDevices);
      expect(result).toHaveLength(3);
    });

    it('should get devices with user information', async () => {
      const mockDevices: Device[] = [
        {
          id: 'device-1',
          name: 'MacBook Pro',
          manufacturer: 'Apple',
          isActive: true,
          userId: 'user-123',
          user: {
            id: 'user-123',
            firstName: 'John',
            lastName: 'Doe',
            email: 'john@example.com',
          },
          createdAt: '2026-01-01T10:00:00Z',
          updatedAt: '2026-01-01T10:00:00Z',
        },
      ];

      mockPost.mockResolvedValue({ data: mockDevices });

      const result = await deviceService.getAllDevices();

      expect(result[0].user).toBeDefined();
      expect(result[0].user?.firstName).toBe('John');
    });

    it('should handle error when fetching devices', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
      });

      await expect(deviceService.getAllDevices())
        .rejects.toThrow('Fehler beim Laden der Geräte');
    });

    it('should return empty array when no devices exist', async () => {
      mockPost.mockResolvedValue({ data: [] });

      const result = await deviceService.getAllDevices();

      expect(result).toEqual([]);
      expect(result).toHaveLength(0);
    });
  });

  describe('READ - getDeviceById', () => {
    it('should get device by id', async () => {
      const mockDevice: Device = {
        id: 'device-123',
        name: 'MacBook Pro 16"',
        serialNumber: 'C02ABC123DEF',
        manufacturer: 'Apple',
        model: 'MacBook Pro 16-inch 2023',
        category: 'Laptop',
        purchaseDate: '2023-05-15',
        warrantyUntil: '2026-05-15',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.getDeviceById('device-123');

      // Axios mock call verification
      expect(result).toEqual(mockDevice);
      expect(result.id).toBe('device-123');
    });

    it('should get device with user assignment', async () => {
      const mockDevice: Device = {
        id: 'device-123',
        name: 'MacBook Pro',
        manufacturer: 'Apple',
        isActive: true,
        userId: 'user-456',
        user: {
          id: 'user-456',
          firstName: 'Jane',
          lastName: 'Smith',
          email: 'jane@example.com',
        },
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.getDeviceById('device-123');

      expect(result.userId).toBe('user-456');
      expect(result.user?.firstName).toBe('Jane');
    });

    it('should handle not found error', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
      });

      await expect(deviceService.getDeviceById('nonexistent-id'))
        .rejects.toThrow('Fehler beim Laden des Geräts');
    });
  });

  describe('READ - getDevicesByUser', () => {
    it('should get devices for specific user', async () => {
      const mockDevices: Device[] = [
        {
          id: 'device-1',
          name: 'MacBook Pro',
          manufacturer: 'Apple',
          isActive: true,
          userId: 'user-123',
          createdAt: '2026-01-01T10:00:00Z',
          updatedAt: '2026-01-01T10:00:00Z',
        },
        {
          id: 'device-2',
          name: 'iPhone 15',
          manufacturer: 'Apple',
          isActive: true,
          userId: 'user-123',
          createdAt: '2026-01-01T10:30:00Z',
          updatedAt: '2026-01-01T10:30:00Z',
        },
      ];

      mockPost.mockResolvedValue({ data: mockDevices });

      const result = await deviceService.getDevicesByUser('user-123');

      // Axios mock call verification
      expect(result).toHaveLength(2);
      expect(result.every(d => d.userId === 'user-123')).toBe(true);
    });

    it('should return empty array when user has no devices', async () => {
      mockPost.mockResolvedValue({ data: [] });

      const result = await deviceService.getDevicesByUser('user-456');

      expect(result).toEqual([]);
      expect(result).toHaveLength(0);
    });

    it('should handle error when fetching user devices', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
      });

      await expect(deviceService.getDevicesByUser('user-123'))
        .rejects.toThrow('Fehler beim Laden der Benutzergeräte');
    });
  });

  // ============================================
  // UPDATE Tests
  // ============================================
  describe('UPDATE - updateDevice', () => {
    it('should update device name', async () => {
      const updates: Partial<Device> = {
        name: 'Updated MacBook Pro',
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'Updated MacBook Pro',
        manufacturer: 'Apple',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T12:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      // Axios mock call verification
      expect(result.name).toBe('Updated MacBook Pro');
      expect(result.updatedAt).not.toBe(result.createdAt);
    });

    it('should update device serial number', async () => {
      const updates: Partial<Device> = {
        serialNumber: 'NEW-SERIAL-123',
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'MacBook Pro',
        serialNumber: 'NEW-SERIAL-123',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T12:30:00Z',
      };

      mockPost.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result.serialNumber).toBe('NEW-SERIAL-123');
    });

    it('should update device warranty dates', async () => {
      const updates: Partial<Device> = {
        purchaseDate: '2025-06-01',
        warrantyUntil: '2028-06-01',
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'Test Device',
        purchaseDate: '2025-06-01',
        warrantyUntil: '2028-06-01',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T13:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result.purchaseDate).toBe('2025-06-01');
      expect(result.warrantyUntil).toBe('2028-06-01');
    });

    it('should update device notes', async () => {
      const updates: Partial<Device> = {
        notes: 'Updated notes: Device needs screen replacement',
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'Test Device',
        notes: 'Updated notes: Device needs screen replacement',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T13:30:00Z',
      };

      mockPost.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result.notes).toBe('Updated notes: Device needs screen replacement');
    });

    it('should deactivate device', async () => {
      const updates: Partial<Device> = {
        isActive: false,
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'Test Device',
        isActive: false,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T14:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result.isActive).toBe(false);
    });

    it('should reactivate device', async () => {
      const updates: Partial<Device> = {
        isActive: true,
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'Test Device',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T14:30:00Z',
      };

      mockPost.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result.isActive).toBe(true);
    });

    it('should update all fields at once', async () => {
      const updates: Partial<Device> = {
        name: 'Completely Updated Device',
        serialNumber: 'UPDATE-999',
        manufacturer: 'New Manufacturer',
        model: 'New Model 2026',
        category: 'Laptop',
        purchaseDate: '2026-01-01',
        warrantyUntil: '2029-01-01',
        notes: 'All fields updated',
        isActive: false,
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'Completely Updated Device',
        serialNumber: 'UPDATE-999',
        manufacturer: 'New Manufacturer',
        model: 'New Model 2026',
        category: 'Laptop',
        purchaseDate: '2026-01-01',
        warrantyUntil: '2029-01-01',
        notes: 'All fields updated',
        isActive: false,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T15:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result).toMatchObject(updates);
    });

    it('should handle update error', async () => {
      const updates: Partial<Device> = {
        serialNumber: 'DUPLICATE-SERIAL',
      };

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        json: async () => ({ error: 'Serial number already in use' }),
      });

      await expect(deviceService.updateDevice('device-123', updates))
        .rejects.toThrow('Serial number already in use');
    });

    it('should handle not found error on update', async () => {
      const updates: Partial<Device> = {
        name: 'Updated Name',
      };

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        json: async () => ({}),
      });

      await expect(deviceService.updateDevice('nonexistent-id', updates))
        .rejects.toThrow('Fehler beim Aktualisieren des Geräts');
    });
  });

  // ============================================
  // DELETE Tests
  // ============================================
  describe('DELETE - deleteDevice', () => {
    it('should delete device successfully', async () => {
      mockDelete.mockResolvedValue({});

      await deviceService.deleteDevice('device-123');

      // Axios mock call verification
    });

    it('should delete multiple devices', async () => {
      const deviceIds = ['device-1', 'device-2', 'device-3'];

      mockDelete.mockResolvedValue({});

      for (const id of deviceIds) {
        await deviceService.deleteDevice(id);
      }

      // Axios mock call count verification
    });

    it('should handle delete error', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
      });

      await expect(deviceService.deleteDevice('device-123'))
        .rejects.toThrow('Fehler beim Löschen des Geräts');
    });
  });

  // ============================================
  // Device Assignment Tests
  // ============================================
  describe('DEVICE ASSIGNMENT - assignDevice', () => {
    it('should assign device to user', async () => {
      const mockAssignment: DeviceAssignment = {
        id: 'assignment-123',
        deviceId: 'device-123',
        userId: 'user-456',
        assignedAt: '2026-01-01T10:00:00Z',
        notes: 'Assigned for project work',
      };

      mockPost.mockResolvedValue({ data: mockAssignment });

      const result = await deviceService.assignDevice('device-123', 'user-456', 'Assigned for project work');

      // Axios mock call verification
      expect(result.deviceId).toBe('device-123');
      expect(result.userId).toBe('user-456');
    });

    it('should assign device without notes', async () => {
      const mockAssignment: DeviceAssignment = {
        id: 'assignment-456',
        deviceId: 'device-123',
        userId: 'user-789',
        assignedAt: '2026-01-01T10:30:00Z',
      };

      mockPost.mockResolvedValue({ data: mockAssignment });

      const result = await deviceService.assignDevice('device-123', 'user-789');

      expect(result.notes).toBeUndefined();
    });

    it('should handle assignment error', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
      });

      await expect(deviceService.assignDevice('device-123', 'user-456'))
        .rejects.toThrow('Fehler beim Zuweisen des Geräts');
    });
  });

  describe('DEVICE ASSIGNMENT - returnDevice', () => {
    it('should return device from user', async () => {
      mockDelete.mockResolvedValue({});

      await deviceService.returnDevice('device-123', 'Device returned in good condition');

      // Axios mock call verification
    });

    it('should return device without notes', async () => {
      mockDelete.mockResolvedValue({});

      await deviceService.returnDevice('device-123');

      // Axios mock call verification
    });

    it('should handle return error', async () => {
      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
      });

      await expect(deviceService.returnDevice('device-123'))
        .rejects.toThrow('Fehler beim Zurückgeben des Geräts');
    });
  });

  // ============================================
  // Integration Tests
  // ============================================
  describe('INTEGRATION - Device Lifecycle', () => {
    it('should complete full CRUD lifecycle', async () => {
      // CREATE
      const newDevice: Partial<Device> = {
        name: 'Lifecycle Test Device',
        serialNumber: 'LIFECYCLE-123',
        manufacturer: 'Test Manufacturer',
        isActive: true,
      };

      const createdDevice: Device = {
        id: 'device-lifecycle',
        name: 'Lifecycle Test Device',
        serialNumber: 'LIFECYCLE-123',
        manufacturer: 'Test Manufacturer',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => createdDevice,
      });

      const created = await deviceService.createDevice(newDevice);
      expect(created.id).toBe('device-lifecycle');

      // READ
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => createdDevice,
      });

      const fetched = await deviceService.getDeviceById('device-lifecycle');
      expect(fetched.name).toBe('Lifecycle Test Device');

      // UPDATE
      const updates: Partial<Device> = {
        name: 'Updated Lifecycle Device',
        notes: 'Device has been updated',
      };

      const updatedDevice: Device = {
        ...createdDevice,
        name: 'Updated Lifecycle Device',
        notes: 'Device has been updated',
        updatedAt: '2026-01-01T12:00:00Z',
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => updatedDevice,
      });

      const updated = await deviceService.updateDevice('device-lifecycle', updates);
      expect(updated.name).toBe('Updated Lifecycle Device');

      // DELETE
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
      });

      await deviceService.deleteDevice('device-lifecycle');
      expect(global.fetch).toHaveBeenLastCalledWith(
        expect.stringContaining('/api/devices/device-lifecycle'),
        expect.objectContaining({ method: 'DELETE' })
      );
    });

    it('should complete device assignment lifecycle', async () => {
      const deviceId = 'device-assignment';
      const userId = 'user-123';

      // CREATE device
      const newDevice: Partial<Device> = {
        name: 'Assignment Test Device',
      };

      const createdDevice: Device = {
        id: deviceId,
        name: 'Assignment Test Device',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => createdDevice,
      });

      await deviceService.createDevice(newDevice);

      // ASSIGN device
      const mockAssignment: DeviceAssignment = {
        id: 'assignment-1',
        deviceId: deviceId,
        userId: userId,
        assignedAt: '2026-01-01T11:00:00Z',
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => mockAssignment,
      });

      const assignment = await deviceService.assignDevice(deviceId, userId);
      expect(assignment.deviceId).toBe(deviceId);

      // RETURN device
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
      });

      await deviceService.returnDevice(deviceId);
      expect(global.fetch).toHaveBeenLastCalledWith(
        expect.stringContaining(`/api/devices/${deviceId}/return`),
        expect.any(Object)
      );
    });
  });

  // ============================================
  // Edge Cases and Error Handling
  // ============================================
  describe('EDGE CASES', () => {
    it('should handle device with expired warranty', async () => {
      const deviceData: Partial<Device> = {
        name: 'Old Device',
        purchaseDate: '2020-01-01',
        warrantyUntil: '2022-01-01', // Expired
      };

      const mockDevice: Device = {
        id: 'device-expired',
        ...deviceData as Device,
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(deviceData);

      expect(result.warrantyUntil).toBe('2022-01-01');
    });

    it('should handle device with very long serial number', async () => {
      const longSerial = 'ABC-123-DEF-456-GHI-789-JKL-012-MNO-345';
      const deviceData: Partial<Device> = {
        name: 'Test Device',
        serialNumber: longSerial,
      };

      const mockDevice: Device = {
        id: 'device-long-serial',
        name: 'Test Device',
        serialNumber: longSerial,
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(deviceData);

      expect(result.serialNumber).toBe(longSerial);
    });

    it('should handle device with special characters in name', async () => {
      const deviceData: Partial<Device> = {
        name: 'MacBook Pro 16" M2 Max (2023)',
        model: 'A2485 / MNW83LL/A',
      };

      const mockDevice: Device = {
        id: 'device-special',
        ...deviceData as Device,
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(deviceData);

      expect(result.name).toBe('MacBook Pro 16" M2 Max (2023)');
    });

    it('should handle device with very long notes', async () => {
      const longNotes = 'Device specifications and history: '.repeat(50);
      const deviceData: Partial<Device> = {
        name: 'Device with Notes',
        notes: longNotes,
      };

      const mockDevice: Device = {
        id: 'device-notes',
        name: 'Device with Notes',
        notes: longNotes,
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockPost.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(deviceData);

      expect(result.notes?.length).toBeGreaterThan(1000);
    });

    it('should handle device without authentication token', async () => {
      localStorageMock.clear();

      const deviceData: Partial<Device> = {
        name: 'Test Device',
      };

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        json: async () => ({ error: 'Unauthorized' }),
      });

      await expect(deviceService.createDevice(deviceData))
        .rejects.toThrow();
    });
  });
});


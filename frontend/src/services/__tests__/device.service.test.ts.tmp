import { deviceService, Device, DeviceAssignment } from '../device.service';
import axios from 'axios';

// Mock axios
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

// Mock localStorage
const localStorageMock = (() => {
  let store: Record<string, string> = {};

  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => {
      store[key] = value.toString();
    },
    removeItem: (key: string) => {
      delete store[key];
    },
    clear: () => {
      store = {};
    },
  };
})();

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock,
});

// Create a mock axios instance
const mockAxiosInstance = {
  get: jest.fn(),
  post: jest.fn(),
  put: jest.fn(),
  delete: jest.fn(),
  interceptors: {
    request: {
      use: jest.fn((successFn) => successFn({ headers: {} })),
    },
  },
};

// Mock axios.create to return our mocked instance
mockedAxios.create = jest.fn(() => mockAxiosInstance as any);

describe('Device Service - Complete CRUD Tests', () => {
  const mockToken = 'test-token-123';

  beforeEach(() => {
    jest.clearAllMocks();
    localStorageMock.clear();
    localStorageMock.setItem('token', mockToken);
    
    // Reset all mock implementations
    mockAxiosInstance.get.mockReset();
    mockAxiosInstance.post.mockReset();
    mockAxiosInstance.put.mockReset();
    mockAxiosInstance.delete.mockReset();
  });

  afterEach(() => {
    localStorageMock.clear();
  });

  // ============================================
  // CREATE Tests
  // ============================================
  describe('CREATE - createDevice', () => {
    it('should create device with all fields', async () => {
      const newDeviceData: Partial<Device> = {
        name: 'MacBook Pro 16"',
        serialNumber: 'C02ABC123DEF',
        manufacturer: 'Apple',
        model: 'MacBook Pro 16-inch 2023',
        category: 'Laptop',
        purchaseDate: '2023-05-15',
        warrantyUntil: '2026-05-15',
        notes: 'High-performance laptop for development',
        isActive: true,
      };

      const mockCreatedDevice: Device = {
        id: 'device-123',
        name: 'MacBook Pro 16"',
        serialNumber: 'C02ABC123DEF',
        manufacturer: 'Apple',
        model: 'MacBook Pro 16-inch 2023',
        category: 'Laptop',
        purchaseDate: '2023-05-15',
        warrantyUntil: '2026-05-15',
        notes: 'High-performance laptop for development',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockCreatedDevice });

      const result = await deviceService.createDevice(newDeviceData);

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/devices'),
        expect.objectContaining({
          method: 'POST',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
          }),
          body: JSON.stringify(newDeviceData),
        })
      );
      expect(result).toEqual(mockCreatedDevice);
      expect(result.id).toBe('device-123');
      expect(result.serialNumber).toBe('C02ABC123DEF');
    });

    it('should create device with minimal required fields', async () => {
      const minimalData: Partial<Device> = {
        name: 'Generic Laptop',
      };

      const mockDevice: Device = {
        id: 'device-456',
        name: 'Generic Laptop',
        isActive: true,
        createdAt: '2026-01-01T10:30:00Z',
        updatedAt: '2026-01-01T10:30:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(minimalData);

      expect(result.name).toBe('Generic Laptop');
      expect(result.isActive).toBe(true);
    });

    it('should create inactive device', async () => {
      const inactiveDevice: Partial<Device> = {
        name: 'Old ThinkPad',
        serialNumber: 'PF123ABC',
        manufacturer: 'Lenovo',
        isActive: false,
      };

      const mockDevice: Device = {
        id: 'device-789',
        name: 'Old ThinkPad',
        serialNumber: 'PF123ABC',
        manufacturer: 'Lenovo',
        isActive: false,
        createdAt: '2026-01-01T11:00:00Z',
        updatedAt: '2026-01-01T11:00:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(inactiveDevice);

      expect(result.isActive).toBe(false);
      expect(result.name).toBe('Old ThinkPad');
    });

    it('should create device with warranty information', async () => {
      const deviceWithWarranty: Partial<Device> = {
        name: 'Dell XPS 15',
        serialNumber: 'DXPS123456',
        manufacturer: 'Dell',
        purchaseDate: '2025-01-15',
        warrantyUntil: '2028-01-15',
      };

      const mockDevice: Device = {
        id: 'device-warranty',
        ...deviceWithWarranty as Device,
        isActive: true,
        createdAt: '2026-01-01T11:30:00Z',
        updatedAt: '2026-01-01T11:30:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(deviceWithWarranty);

      expect(result.purchaseDate).toBe('2025-01-15');
      expect(result.warrantyUntil).toBe('2028-01-15');
    });

    it('should handle creation error', async () => {
      const deviceData: Partial<Device> = {
        name: 'Test Device',
        serialNumber: 'DUPLICATE123',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevice });

        const result = await deviceService.createDevice(deviceData);
        expect(result.category).toBe(category);
      }
    });
  });

  // ============================================
  // READ Tests
  // ============================================
  describe('READ - getAllDevices', () => {
    it('should get all devices', async () => {
      const mockDevices: Device[] = [
        {
          id: 'device-1',
          name: 'MacBook Pro',
          manufacturer: 'Apple',
          isActive: true,
          createdAt: '2026-01-01T10:00:00Z',
          updatedAt: '2026-01-01T10:00:00Z',
        },
        {
          id: 'device-2',
          name: 'ThinkPad X1',
          manufacturer: 'Lenovo',
          isActive: true,
          createdAt: '2026-01-01T10:30:00Z',
          updatedAt: '2026-01-01T10:30:00Z',
        },
        {
          id: 'device-3',
          name: 'Dell Monitor',
          manufacturer: 'Dell',
          isActive: false,
          createdAt: '2026-01-01T11:00:00Z',
          updatedAt: '2026-01-01T11:00:00Z',
        },
      ];

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevices });

      const result = await deviceService.getAllDevices();

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/devices'),
        expect.objectContaining({
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
          }),
        })
      );
      expect(result).toEqual(mockDevices);
      expect(result).toHaveLength(3);
    });

    it('should get devices with user information', async () => {
      const mockDevices: Device[] = [
        {
          id: 'device-1',
          name: 'MacBook Pro',
          manufacturer: 'Apple',
          isActive: true,
          userId: 'user-123',
          user: {
            id: 'user-123',
            firstName: 'John',
            lastName: 'Doe',
            email: 'john@example.com',
          },
          createdAt: '2026-01-01T10:00:00Z',
          updatedAt: '2026-01-01T10:00:00Z',
        },
      ];

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevices });

      const result = await deviceService.getAllDevices();

      expect(result[0].user).toBeDefined();
      expect(result[0].user?.firstName).toBe('John');
    });

    it('should handle error when fetching devices', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: [] });

      const result = await deviceService.getAllDevices();

      expect(result).toEqual([]);
      expect(result).toHaveLength(0);
    });
  });

  describe('READ - getDeviceById', () => {
    it('should get device by id', async () => {
      const mockDevice: Device = {
        id: 'device-123',
        name: 'MacBook Pro 16"',
        serialNumber: 'C02ABC123DEF',
        manufacturer: 'Apple',
        model: 'MacBook Pro 16-inch 2023',
        category: 'Laptop',
        purchaseDate: '2023-05-15',
        warrantyUntil: '2026-05-15',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.getDeviceById('device-123');

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/devices/device-123'),
        expect.any(Object)
      );
      expect(result).toEqual(mockDevice);
      expect(result.id).toBe('device-123');
    });

    it('should get device with user assignment', async () => {
      const mockDevice: Device = {
        id: 'device-123',
        name: 'MacBook Pro',
        manufacturer: 'Apple',
        isActive: true,
        userId: 'user-456',
        user: {
          id: 'user-456',
          firstName: 'Jane',
          lastName: 'Smith',
          email: 'jane@example.com',
        },
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.getDeviceById('device-123');

      expect(result.userId).toBe('user-456');
      expect(result.user?.firstName).toBe('Jane');
    });

    it('should handle not found error', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: mockDevices });

      const result = await deviceService.getDevicesByUser('user-123');

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/devices/user/user-123'),
        expect.any(Object)
      );
      expect(result).toHaveLength(2);
      expect(result.every(d => d.userId === 'user-123')).toBe(true);
    });

    it('should return empty array when user has no devices', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: [] });

      const result = await deviceService.getDevicesByUser('user-456');

      expect(result).toEqual([]);
      expect(result).toHaveLength(0);
    });

    it('should handle error when fetching user devices', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/devices/device-123'),
        expect.objectContaining({
          method: 'PUT',
          body: JSON.stringify(updates),
        })
      );
      expect(result.name).toBe('Updated MacBook Pro');
      expect(result.updatedAt).not.toBe(result.createdAt);
    });

    it('should update device serial number', async () => {
      const updates: Partial<Device> = {
        serialNumber: 'NEW-SERIAL-123',
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'MacBook Pro',
        serialNumber: 'NEW-SERIAL-123',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T12:30:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result.serialNumber).toBe('NEW-SERIAL-123');
    });

    it('should update device warranty dates', async () => {
      const updates: Partial<Device> = {
        purchaseDate: '2025-06-01',
        warrantyUntil: '2028-06-01',
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'Test Device',
        purchaseDate: '2025-06-01',
        warrantyUntil: '2028-06-01',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T13:00:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result.purchaseDate).toBe('2025-06-01');
      expect(result.warrantyUntil).toBe('2028-06-01');
    });

    it('should update device notes', async () => {
      const updates: Partial<Device> = {
        notes: 'Updated notes: Device needs screen replacement',
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'Test Device',
        notes: 'Updated notes: Device needs screen replacement',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T13:30:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result.notes).toBe('Updated notes: Device needs screen replacement');
    });

    it('should deactivate device', async () => {
      const updates: Partial<Device> = {
        isActive: false,
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'Test Device',
        isActive: false,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T14:00:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result.isActive).toBe(false);
    });

    it('should reactivate device', async () => {
      const updates: Partial<Device> = {
        isActive: true,
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'Test Device',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T14:30:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result.isActive).toBe(true);
    });

    it('should update all fields at once', async () => {
      const updates: Partial<Device> = {
        name: 'Completely Updated Device',
        serialNumber: 'UPDATE-999',
        manufacturer: 'New Manufacturer',
        model: 'New Model 2026',
        category: 'Laptop',
        purchaseDate: '2026-01-01',
        warrantyUntil: '2029-01-01',
        notes: 'All fields updated',
        isActive: false,
      };

      const mockUpdatedDevice: Device = {
        id: 'device-123',
        name: 'Completely Updated Device',
        serialNumber: 'UPDATE-999',
        manufacturer: 'New Manufacturer',
        model: 'New Model 2026',
        category: 'Laptop',
        purchaseDate: '2026-01-01',
        warrantyUntil: '2029-01-01',
        notes: 'All fields updated',
        isActive: false,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T15:00:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockUpdatedDevice });

      const result = await deviceService.updateDevice('device-123', updates);

      expect(result).toMatchObject(updates);
    });

    it('should handle update error', async () => {
      const updates: Partial<Device> = {
        serialNumber: 'DUPLICATE-SERIAL',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockAssignment });

      const result = await deviceService.assignDevice('device-123', 'user-456', 'Assigned for project work');

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/devices/device-123/assign'),
        expect.objectContaining({
          method: 'POST',
          body: JSON.stringify({ userId: 'user-456', notes: 'Assigned for project work' }),
        })
      );
      expect(result.deviceId).toBe('device-123');
      expect(result.userId).toBe('user-456');
    });

    it('should assign device without notes', async () => {
      const mockAssignment: DeviceAssignment = {
        id: 'assignment-456',
        deviceId: 'device-123',
        userId: 'user-789',
        assignedAt: '2026-01-01T10:30:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockAssignment });

      const result = await deviceService.assignDevice('device-123', 'user-789');

      expect(result.notes).toBeUndefined();
    });

    it('should handle assignment error', async () => {
      mockAxiosInstance.post.mockResolvedValue({ data: createdDevice });

      const created = await deviceService.createDevice(newDevice);
      expect(created.id).toBe('device-lifecycle');

      // READ
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => createdDevice,
      });

      const fetched = await deviceService.getDeviceById('device-lifecycle');
      expect(fetched.name).toBe('Lifecycle Test Device');

      // UPDATE
      const updates: Partial<Device> = {
        name: 'Updated Lifecycle Device',
        notes: 'Device has been updated',
      };

      const updatedDevice: Device = {
        ...createdDevice,
        name: 'Updated Lifecycle Device',
        notes: 'Device has been updated',
        updatedAt: '2026-01-01T12:00:00Z',
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => updatedDevice,
      });

      const updated = await deviceService.updateDevice('device-lifecycle', updates);
      expect(updated.name).toBe('Updated Lifecycle Device');

      // DELETE
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
      });

      await deviceService.deleteDevice('device-lifecycle');
      expect(global.fetch).toHaveBeenLastCalledWith(
        expect.stringContaining('/api/devices/device-lifecycle'),
        expect.objectContaining({ method: 'DELETE' })
      );
    });

    it('should complete device assignment lifecycle', async () => {
      const deviceId = 'device-assignment';
      const userId = 'user-123';

      // CREATE device
      const newDevice: Partial<Device> = {
        name: 'Assignment Test Device',
      };

      const createdDevice: Device = {
        id: deviceId,
        name: 'Assignment Test Device',
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => createdDevice,
      });

      await deviceService.createDevice(newDevice);

      // ASSIGN device
      const mockAssignment: DeviceAssignment = {
        id: 'assignment-1',
        deviceId: deviceId,
        userId: userId,
        assignedAt: '2026-01-01T11:00:00Z',
      };

      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => mockAssignment,
      });

      const assignment = await deviceService.assignDevice(deviceId, userId);
      expect(assignment.deviceId).toBe(deviceId);

      // RETURN device
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
      });

      await deviceService.returnDevice(deviceId);
      expect(global.fetch).toHaveBeenLastCalledWith(
        expect.stringContaining(`/api/devices/${deviceId}/return`),
        expect.any(Object)
      );
    });
  });

  // ============================================
  // Edge Cases and Error Handling
  // ============================================
  describe('EDGE CASES', () => {
    it('should handle device with expired warranty', async () => {
      const deviceData: Partial<Device> = {
        name: 'Old Device',
        purchaseDate: '2020-01-01',
        warrantyUntil: '2022-01-01', // Expired
      };

      const mockDevice: Device = {
        id: 'device-expired',
        ...deviceData as Device,
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(deviceData);

      expect(result.warrantyUntil).toBe('2022-01-01');
    });

    it('should handle device with very long serial number', async () => {
      const longSerial = 'ABC-123-DEF-456-GHI-789-JKL-012-MNO-345';
      const deviceData: Partial<Device> = {
        name: 'Test Device',
        serialNumber: longSerial,
      };

      const mockDevice: Device = {
        id: 'device-long-serial',
        name: 'Test Device',
        serialNumber: longSerial,
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(deviceData);

      expect(result.serialNumber).toBe(longSerial);
    });

    it('should handle device with special characters in name', async () => {
      const deviceData: Partial<Device> = {
        name: 'MacBook Pro 16" M2 Max (2023)',
        model: 'A2485 / MNW83LL/A',
      };

      const mockDevice: Device = {
        id: 'device-special',
        ...deviceData as Device,
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(deviceData);

      expect(result.name).toBe('MacBook Pro 16" M2 Max (2023)');
    });

    it('should handle device with very long notes', async () => {
      const longNotes = 'Device specifications and history: '.repeat(50);
      const deviceData: Partial<Device> = {
        name: 'Device with Notes',
        notes: longNotes,
      };

      const mockDevice: Device = {
        id: 'device-notes',
        name: 'Device with Notes',
        notes: longNotes,
        isActive: true,
        createdAt: '2026-01-01T10:00:00Z',
        updatedAt: '2026-01-01T10:00:00Z',
      };

      mockAxiosInstance.post.mockResolvedValue({ data: mockDevice });

      const result = await deviceService.createDevice(deviceData);

      expect(result.notes?.length).toBeGreaterThan(1000);
    });

    it('should handle device without authentication token', async () => {
      localStorageMock.clear();

      const deviceData: Partial<Device> = {
        name: 'Test Device',
      };

      (global.fetch as jest.Mock).mockResolvedValue({
        ok: false,
        json: async () => ({ error: 'Unauthorized' }),
      });

      await expect(deviceService.createDevice(deviceData))
        .rejects.toThrow();
    });
  });
});

